---
import type { ActiveProgram } from "@types";

interface Props {
  channelId: string;
  activeProgram?: ActiveProgram | null;
}

const { activeProgram } = Astro.props;
const { program, startTime, endTime } = activeProgram ?? {};
const { title, url } = program ?? {};

function getReadableTime(timeStr: string | undefined) {
  if (!timeStr) return "00:00";

  // Create a new date and set it to the time from the string
  const [hours, minutes] = timeStr.split(":").map(Number);
  const date = new Date();
  date.setUTCHours(hours, minutes, 0, 0);

  return date.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: true,
  });
}

const readableEndTime = getReadableTime(endTime)?.split(" ")[0];
const isAm = getReadableTime(endTime)?.split(" ")[1] === "AM";

const hasProgram = program !== null;
const hasTiming = Boolean(startTime && endTime) && program !== null;
---

<channel-display data-title={title} data-url={url} data-power="on">
  <svg
    width="328"
    height="64"
    viewBox="0 0 328 64"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <rect width="328" height="64" rx="16" fill="#0E0E0E" class="display"></rect>
    <g class="title">
      <text
        x="18"
        y="34"
        class="title-background"
        fill="#283741"
        fill-opacity="0.6"
        font-size="21">#################</text
      >
      <text x="18" y="34" class="title-contents" fill="#5EBFFD" font-size="21">
        {
          program && title ? (
            url ? (
              <a href={url}>{title.slice(0, 17).toUpperCase()}</a>
            ) : (
              <tspan>{title.slice(0, 17).toUpperCase()}</tspan>
            )
          ) : (
            <tspan>NOTHING SCHEDULED</tspan>
          )
        }
      </text>
    </g>
    <g class="secondary">
      <circle
        cx="21"
        cy="48"
        r="3"
        fill="#283741"
        fill-opacity="0.6"
        class="airing-indicator"
        data-active={hasProgram}></circle>
      <text
        x="30"
        y="52"
        class="airing-text"
        fill="#283741"
        fill-opacity="0.6"
        font-size="12"
        letter-spacing="1.3"
      >
        <tspan class="live" data-active={hasProgram}>LIVE</tspan>
        <tspan class="until" data-active={hasTiming}>UNTIL</tspan>
        <tspan class="time" data-active={hasTiming}>{readableEndTime}</tspan>
        <tspan
          class="am-pm am"
          data-active={Boolean(isAm && hasTiming)}
          aria-hidden={Boolean(!isAm || !hasTiming)}
        >
          AM
        </tspan>
        <tspan
          class="am-pm pm"
          data-active={Boolean(!isAm && hasTiming)}
          aria-hidden={Boolean(isAm || !hasTiming)}
        >
          PM
        </tspan>
      </text>
      <text
        class="viewer-count"
        fill="#283741"
        fill-opacity="0.6"
        font-size="12"
        letter-spacing="1.3"
        x="308"
        y="52"
        text-anchor="end"
        transition:persist
      >
        <tspan class="leading-zeros">00</tspan><tspan class="count">1</tspan>
        <tspan>WATCHING</tspan>
      </text>
    </g>
  </svg>
</channel-display>

<style>
  channel-display svg {
    overflow: visible;
  }

  .display {
    filter: drop-shadow(0 2px 1px rgba(255, 255, 255, 0.1));
    user-select: none;
    transition: fill 0.1s ease;
  }

  .title {
    font-family: "DSEG 14", monospace;

    a {
      border-radius: 0.2rem;
    }
  }

  .airing-indicator,
  .live {
    --phosphor-active: rgb(255, 100, 100);
    fill: var(--phosphor-inactive);
  }

  [data-active="true"] {
    fill: var(--phosphor-active);
    fill-opacity: 1;

    .airing-indicator {
      background: var(--phosphor-active);
    }
  }

  [data-power="on"] .viewer-count :not(.leading-zeros) {
    fill: var(--phosphor-active);
    fill-opacity: 1;
  }

  [data-power="off"] {
    .title-contents {
      fill-opacity: 0;
      pointer-events: none;
    }

    [data-active="true"] {
      fill: var(--phosphor-inactive);
      fill-opacity: 0.6;
    }
  }
</style>

<script>
  import { DISPLAY_CONFIG } from "@constants/channelDisplay";

  class ChannelDisplay extends HTMLElement {
    intervalId: number | null = null;
    timeoutId: NodeJS.Timeout | null = null;
    private socket: WebSocket | null = null;
    private isConnecting = false;

    private shouldScrollTitle(): boolean {
      const title = this.dataset.title;
      const isActive = this.dataset.power === "on";
      return Boolean(
        title && title.length > DISPLAY_CONFIG.TITLE_MAX_CHARS && isActive,
      );
    }

    private initializeTitleScroll(): void {
      if (!this.shouldScrollTitle()) return;

      const title = this.dataset.title!;
      this.timeoutId = setTimeout(() => {
        this.scrollTitle(title, DISPLAY_CONFIG.TITLE_MAX_CHARS);
      }, DISPLAY_CONFIG.TITLE_SCROLL_START_DELAY_MS);
    }

    private shouldUpdateTimeDisplay(): boolean {
      const timeElement = this.querySelector("time");
      return Boolean(timeElement?.getAttribute("datetime"));
    }

    connectedCallback(): void {
      this.initializeTitleScroll();

      if (this.shouldUpdateTimeDisplay()) {
        this.updateTimeDisplay();
      }

      // Initialize viewer count WebSocket
      this.connectViewerCount();
    }

    private parseUtcTimeString(timeStr: string): Date {
      const [hours, minutes] = timeStr.split(":").map(Number);
      const date = new Date();
      date.setUTCHours(hours, minutes, 0, 0);
      return date;
    }

    private formatTimeForDisplay(date: Date): {
      time: string;
      period: string;
    } {
      const formatted = date.toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });
      const [time, period] = formatted.split(" ");
      return { time, period };
    }

    private updateAmPmIndicators(isAm: boolean): void {
      const amElement = this.querySelector(".am-pm.am");
      const pmElement = this.querySelector(".am-pm.pm");

      if (amElement && pmElement) {
        amElement.setAttribute("data-active", isAm.toString());
        amElement.setAttribute("aria-hidden", (!isAm).toString());
        pmElement.setAttribute("data-active", (!isAm).toString());
        pmElement.setAttribute("aria-hidden", isAm.toString());
      }
    }

    updateTimeDisplay(): void {
      const timeElement = this.querySelector("time");
      if (!timeElement) return;

      const timeStr = timeElement.getAttribute("datetime");
      if (!timeStr) return;

      const date = this.parseUtcTimeString(timeStr);
      const { time, period } = this.formatTimeForDisplay(date);

      timeElement.textContent = time;
      this.updateAmPmIndicators(period === "AM");
    }

    disconnectedCallback() {
      this.clearTimers();
      this.disconnectViewerCount();
    }

    clearTimers() {
      if (this.intervalId !== null) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      if (this.timeoutId !== null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }

    private connectViewerCount(): void {
      // Skip WebSocket connection in development
      if (import.meta.env.DEV) {
        return;
      }

      // Prevent duplicate connections - close existing socket if any
      if (this.socket) {
        this.socket.close();
        this.socket = null;
      }

      if (this.isConnecting) {
        return;
      }

      this.isConnecting = true;
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const url = `${protocol}//${window.location.host}/api/viewers`;

      try {
        this.socket = new WebSocket(url);

        this.socket.addEventListener("open", () => {
          this.isConnecting = false;
        });

        this.socket.addEventListener("message", (event) => {
          const count = parseInt(event.data) || 1;
          this.updateViewerCount(count);
        });

        this.socket.addEventListener("close", () => {
          this.socket = null;
          this.isConnecting = false;
        });

        this.socket.addEventListener("error", () => {
          this.socket = null;
          this.isConnecting = false;
        });
      } catch (error) {
        this.socket = null;
        this.isConnecting = false;
      }
    }

    private disconnectViewerCount(): void {
      if (this.socket) {
        this.socket.close();
        this.socket = null;
      }
      this.isConnecting = false;
    }

    private updateViewerCount(count: number): void {
      const formatted = count.toString().padStart(3, "0");
      const leadingZeros = formatted.match(/^0+/)?.[0] || "";
      const actualNumber = formatted.slice(leadingZeros.length);

      const leadingZerosElement = this.querySelector(
        ".viewer-count .leading-zeros",
      );
      const countElement = this.querySelector(".viewer-count .count");

      if (leadingZerosElement) {
        leadingZerosElement.textContent = leadingZeros;
      }

      if (countElement) {
        countElement.textContent = actualNumber;
      }
    }

    scrollTitle(title: string, totalChars: number): void {
      const titleLink = this.querySelector(".title a");
      if (!titleLink) return;

      let startIndex = 0;
      let direction = DISPLAY_CONFIG.SCROLL_DIRECTION_FORWARD;
      const maxIndex = Math.max(0, title.length - totalChars);
      let pauseCount = 0;

      const isAtStart = () => startIndex <= 0;
      const isAtEnd = () => startIndex >= maxIndex;
      const isMovingForward = () =>
        direction === DISPLAY_CONFIG.SCROLL_DIRECTION_FORWARD;
      const shouldReverse = () =>
        (isAtEnd() && isMovingForward()) || (isAtStart() && !isMovingForward());

      const reverseDirection = () => {
        direction *= -1;
        pauseCount = isMovingForward()
          ? DISPLAY_CONFIG.TITLE_SCROLL_PAUSE_AT_START
          : DISPLAY_CONFIG.TITLE_SCROLL_PAUSE_AT_END;
      };

      this.intervalId = setInterval(() => {
        if (pauseCount > 0) {
          pauseCount--;
          return;
        }

        const visibleChars = title
          .slice(startIndex, startIndex + totalChars)
          .toUpperCase();
        titleLink.textContent = visibleChars;

        if (shouldReverse()) {
          reverseDirection();
          return;
        }

        startIndex += direction;
      }, DISPLAY_CONFIG.TITLE_SCROLL_INTERVAL_MS) as unknown as number;
    }
  }

  document.addEventListener("astro:page-load", () => {
    if (!customElements.get("channel-display")) {
      customElements.define("channel-display", ChannelDisplay);
    }
  });
</script>
