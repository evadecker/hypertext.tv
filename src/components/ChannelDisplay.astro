---
import type { ActiveProgram } from "@types";
import ViewerCount from "./ViewerCount.astro";

interface Props {
  channelId: string;
  activeProgram?: ActiveProgram | null;
}

const { activeProgram } = Astro.props;
const { program, startTime, endTime } = activeProgram ?? {};
const { title, url } = program ?? {};

function getReadableTime(timeStr: string | undefined) {
  if (!timeStr) return "00:00";

  // Create a new date and set it to the time from the string
  const [hours, minutes] = timeStr.split(":").map(Number);
  const date = new Date();
  date.setUTCHours(hours, minutes, 0, 0);

  return date.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: true,
  });
}

const readableEndTime = getReadableTime(endTime)?.split(" ")[0];
const isAm = getReadableTime(endTime)?.split(" ")[1] === "AM";

const isAiring = Boolean(startTime && endTime) && program !== null;
---

<channel-display data-title={title} data-url={url} data-power="on">
  <header class="display">
    <div
      class="title"
      data-title={title}
      data-scroll={Boolean((title?.length ?? 0) > 17)}
    >
      <span class="title-contents">
        {
          program && program.url ? (
            <a href={url}>{title?.slice(0, 17)}</a>
          ) : program ? (
            <span>{title?.slice(0, 17)}</span>
          ) : (
            <span>Nothing scheduled</span>
          )
        }
      </span>
      <span class="title-background" aria-hidden="true">#################</span>
    </div>

    <div class="secondary">
      <div class="airing-container">
        <div
          class="airing"
          data-active={isAiring || title === "What's Airing Now"}
          transition:persist
        >
          <div class="airing-indicator" transition:persist></div>
          Live
        </div>
        <div class="times">
          <span data-active={isAiring}>Until</span>
          <time datetime={endTime} data-active={isAiring}>
            {readableEndTime}
          </time>
          <span
            class="am-pm am"
            data-active={Boolean(isAm && isAiring)}
            aria-hidden={Boolean(!isAm || !isAiring)}
          >
            AM
          </span>
          <span
            class="am-pm pm"
            data-active={Boolean(!isAm && isAiring)}
            aria-hidden={Boolean(isAm || !isAiring)}
          >
            PM
          </span>
        </div>
      </div>
      <ViewerCount />
    </div>
  </header>
</channel-display>

<style is:global>
  @keyframes scroll-text {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(-100%);
    }
  }

  @keyframes live-pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
    100% {
      opacity: 1;
    }
  }

  channel-display .display {
    background: black;
    border-radius: 1rem;
    height: 4rem;
    width: 20rem;
    font-size: 1.3rem;
    padding-inline: 1rem;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: center;
    gap: 0.5rem;
    box-shadow: 0 2px 1px rgba(255, 255, 255, 0.1);
    user-select: none;
    line-height: 1;
    overflow: hidden;
    text-transform: uppercase;

    a {
      color: var(--phosphor-active);
      text-decoration: none;
    }

    .title {
      font-family: "DSEG 14", monospace;
      font-weight: 400;
      color: var(--phosphor-active);
      text-shadow: var(--phosphor-glow);
      text-wrap: nowrap;
      line-height: 1;
      display: flex;
      align-items: center;
      gap: 0.5em;

      &[data-scroll="true"] a {
        white-space: pre;
      }

      a {
        border-radius: 0.2rem;
      }
    }

    .title-contents {
      position: absolute;
      z-index: 1;
    }

    .title-background {
      color: var(--phosphor-inactive);
      opacity: 0.6;
      z-index: 0;
      pointer-events: none;
    }

    .secondary {
      color: color-mix(in srgb, var(--phosphor-active) 40%, transparent);
      font-size: 0.55em;
      margin-bottom: -0.4rem;
      display: flex;
      justify-content: space-between;
      width: 100%;
      letter-spacing: 0.1em;
      white-space: nowrap;
    }

    .airing {
      --phosphor-active: rgb(255, 100, 100);
      color: var(--phosphor-inactive);
      display: flex;
      align-items: center;
    }

    .airing-indicator {
      content: "";
      display: inline-block;
      width: 0.5em;
      height: 0.5em;
      background: var(--phosphor-inactive);
      border-radius: 50%;
      margin-right: 0.5em;
      transform: translateY(-0.05em);
    }

    .airing-container {
      display: flex;
      align-items: center;
      gap: 0.5em;
    }

    .times {
      color: var(--phosphor-inactive);
    }

    [data-active="true"] {
      color: var(--phosphor-active);
      text-shadow: var(--phosphor-glow);

      .airing-indicator {
        background: var(--phosphor-active);
        box-shadow: var(--phosphor-glow);
      }
    }
  }

  [data-power="off"] {
    .title-contents {
      opacity: 0;
      pointer-events: none;
    }

    [data-active="true"] {
      color: var(--phosphor-inactive);
      text-shadow: none;

      .airing-indicator {
        background: var(--phosphor-inactive);
        box-shadow: none;
        animation: none;
      }
    }
  }
</style>

<script>
  import { DISPLAY_CONFIG } from "@constants/channelDisplay";

  class ChannelDisplay extends HTMLElement {
    intervalId: number | null = null;
    timeoutId: NodeJS.Timeout | null = null;

    private shouldScrollTitle(): boolean {
      const title = this.dataset.title;
      const isActive = this.dataset.power === "on";
      return Boolean(
        title && title.length > DISPLAY_CONFIG.TITLE_MAX_CHARS && isActive,
      );
    }

    private initializeTitleScroll(): void {
      if (!this.shouldScrollTitle()) return;

      const title = this.dataset.title!;
      this.timeoutId = setTimeout(() => {
        this.scrollTitle(title, DISPLAY_CONFIG.TITLE_MAX_CHARS);
      }, DISPLAY_CONFIG.TITLE_SCROLL_START_DELAY_MS);
    }

    private shouldUpdateTimeDisplay(): boolean {
      const timeElement = this.querySelector("time");
      return Boolean(timeElement?.getAttribute("datetime"));
    }

    connectedCallback(): void {
      this.initializeTitleScroll();

      if (this.shouldUpdateTimeDisplay()) {
        this.updateTimeDisplay();
      }
    }

    private parseUtcTimeString(timeStr: string): Date {
      const [hours, minutes] = timeStr.split(":").map(Number);
      const date = new Date();
      date.setUTCHours(hours, minutes, 0, 0);
      return date;
    }

    private formatTimeForDisplay(date: Date): { time: string; period: string } {
      const formatted = date.toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: true,
      });
      const [time, period] = formatted.split(" ");
      return { time, period };
    }

    private updateAmPmIndicators(isAm: boolean): void {
      const amElement = this.querySelector(".am-pm.am");
      const pmElement = this.querySelector(".am-pm.pm");

      if (amElement && pmElement) {
        amElement.setAttribute("data-active", isAm.toString());
        amElement.setAttribute("aria-hidden", (!isAm).toString());
        pmElement.setAttribute("data-active", (!isAm).toString());
        pmElement.setAttribute("aria-hidden", isAm.toString());
      }
    }

    updateTimeDisplay(): void {
      const timeElement = this.querySelector("time");
      if (!timeElement) return;

      const timeStr = timeElement.getAttribute("datetime");
      if (!timeStr) return;

      const date = this.parseUtcTimeString(timeStr);
      const { time, period } = this.formatTimeForDisplay(date);

      timeElement.textContent = time;
      this.updateAmPmIndicators(period === "AM");
    }

    disconnectedCallback() {
      this.clearTimers();
    }

    clearTimers() {
      if (this.intervalId !== null) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      if (this.timeoutId !== null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }

    scrollTitle(title: string, totalChars: number): void {
      const titleLink = this.querySelector(".title a");
      if (!titleLink) return;

      let startIndex = 0;
      let direction = DISPLAY_CONFIG.SCROLL_DIRECTION_FORWARD;
      const maxIndex = Math.max(0, title.length - totalChars);
      let pauseCount = 0;

      const isAtStart = () => startIndex <= 0;
      const isAtEnd = () => startIndex >= maxIndex;
      const isMovingForward = () =>
        direction === DISPLAY_CONFIG.SCROLL_DIRECTION_FORWARD;
      const shouldReverse = () =>
        (isAtEnd() && isMovingForward()) || (isAtStart() && !isMovingForward());

      const reverseDirection = () => {
        direction *= -1;
        pauseCount = isMovingForward()
          ? DISPLAY_CONFIG.TITLE_SCROLL_PAUSE_AT_START
          : DISPLAY_CONFIG.TITLE_SCROLL_PAUSE_AT_END;
      };

      this.intervalId = setInterval(() => {
        if (pauseCount > 0) {
          pauseCount--;
          return;
        }

        const visibleChars = title.slice(startIndex, startIndex + totalChars);
        titleLink.textContent = visibleChars;

        if (shouldReverse()) {
          reverseDirection();
          return;
        }

        startIndex += direction;
      }, DISPLAY_CONFIG.TITLE_SCROLL_INTERVAL_MS) as unknown as number;
    }
  }

  document.addEventListener("astro:page-load", () => {
    if (!customElements.get("channel-display")) {
      customElements.define("channel-display", ChannelDisplay);
    }
  });
</script>
